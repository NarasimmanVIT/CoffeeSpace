name: Deploy Frontend to EC2 via SSM

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      # --- Load .env file ---
      - name: Load .env
        run: |
          if [ -f .env ]; then
            export $(grep -v '^#' .env | xargs)
            echo "✅ Loaded .env variables"
            echo "VITE_API_BASE_URL=$VITE_API_BASE_URL" >> $GITHUB_ENV
            echo "AWS_REGION=$AWS_REGION" >> $GITHUB_ENV
            echo "AWS_ACCOUNT_ID=$AWS_ACCOUNT_ID" >> $GITHUB_ENV
            echo "EC2_INSTANCE_IDS=$EC2_INSTANCE_IDS" >> $GITHUB_ENV
          else
            echo "❌ .env file not found"
            exit 1
          fi

      - name: Validate required env vars
        run: |
          [ -n "$VITE_API_BASE_URL" ] && [ -n "$AWS_REGION" ] && [ -n "$AWS_ACCOUNT_ID" ] && [ -n "$EC2_INSTANCE_IDS" ] \
            && echo "✅ All required env vars are set" || { echo "❌ Missing required env vars"; exit 1; }

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        run: |
          aws ecr get-login-password --region "$AWS_REGION" \
          | docker login --username AWS --password-stdin "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"

      - name: Build Docker image
        run: |
          docker build --build-arg VITE_API_BASE_URL="$VITE_API_BASE_URL" -t coffeespace-frontend:latest .

      - name: Tag & Push Docker image
        run: |
          docker tag coffeespace-frontend:latest "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/coffeespace-frontend:latest"
          docker push "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/coffeespace-frontend:latest"

      - name: Deploy to EC2 via SSM
        run: |
          # Store remote script safely in a variable
          REMOTE_SCRIPT=$(cat <<'EOSH'
          set -e
          FRONTEND_DIR=/home/ubuntu/frontend
          mkdir -p "$FRONTEND_DIR"

          # Docker & Compose
          if ! command -v docker >/dev/null 2>&1; then
            sudo apt-get update -y && sudo apt-get install -y docker.io
          fi
          if ! docker compose version >/dev/null 2>&1; then
            sudo apt-get install -y docker-compose-plugin || sudo apt-get install -y docker-compose
          fi

          docker network inspect app_net >/dev/null 2>&1 || docker network create app_net

          # Write .env for Docker Compose
          cat > "$FRONTEND_DIR/.env" <<ENVEOF
          AWS_ACCOUNT_ID=%AWS_ACCOUNT_ID%
          AWS_REGION=%AWS_REGION%
          VITE_API_BASE_URL=%VITE_API_BASE_URL%
          ENVEOF

          # docker-compose.yml
          cat > "$FRONTEND_DIR/docker-compose.yml" <<'YAMLEOF'
          version: "3.9"

          networks:
            app_net:
              external: true

          services:
            frontend:
              image: "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/coffeespace-frontend:latest"
              container_name: coffeespace-frontend
              restart: always
              ports:
                - "80:80"
              networks:
                - app_net
              volumes:
                - ./nginx.conf:/etc/nginx/conf.d/default.conf:ro
          YAMLEOF

          # nginx.conf
          cat > "$FRONTEND_DIR/nginx.conf" <<'NGINXEOF'
          server {
            listen 80;
            server_name _;

            root /usr/share/nginx/html;
            index index.html index.htm;

            location / {
              try_files $uri /index.html;
            }

            location /api/ {
              proxy_pass ${VITE_API_BASE_URL};
              proxy_http_version 1.1;
              proxy_set_header Host $host;
              proxy_set_header X-Real-IP $remote_addr;
              proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto $scheme;
            }
          }
          NGINXEOF

          aws ecr get-login-password --region "%AWS_REGION%" \
            | docker login --username AWS --password-stdin "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"

          docker network connect app_net coffeespace-backend || true

          cd "$FRONTEND_DIR"
          docker compose pull
          docker compose up -d --remove-orphans
          docker image prune -f || true
          EOSH
          )

          # Replace placeholders
          REMOTE_SCRIPT="${REMOTE_SCRIPT//%AWS_REGION%/${AWS_REGION}}"
          REMOTE_SCRIPT="${REMOTE_SCRIPT//%AWS_ACCOUNT_ID%/${AWS_ACCOUNT_ID}}"
          REMOTE_SCRIPT="${REMOTE_SCRIPT//%VITE_API_BASE_URL%/${VITE_API_BASE_URL}}"

          # Debugging: show the script that will run remotely
          echo "----- Final Remote Script -----"
          echo "$REMOTE_SCRIPT"
          echo "-------------------------------"

          # Send command to EC2 via SSM
          COMMAND_ID=$(aws ssm send-command \
             --targets "Key=instanceIds,Values=$EC2_INSTANCE_IDS" \
             --document-name "AWS-RunShellScript" \
             --comment "Deploy latest Docker image" \
            --parameters commands="$REMOTE_SCRIPT" \
             --region "${AWS_REGION}" \
             --query "Command.CommandId" \
             --output text)

          echo "SSM Command ID: $COMMAND_ID"

          # Poll until command finishes
          while true; do
            STATUS=$(aws ssm get-command-invocation \
              --instance-id "${EC2_INSTANCE_IDS}" \
              --command-id "$COMMAND_ID" \
              --query 'Status' --output text)
            echo "Current status: $STATUS"
            [[ "$STATUS" =~ ^(Success|Failed|DeliveryTimedOut|ExecutionTimedOut|Cancelled)$ ]] && break
            sleep 5
          done

          RESPONSE_CODE=$(aws ssm get-command-invocation \
            --instance-id "${EC2_INSTANCE_IDS}" \
            --command-id "$COMMAND_ID" \
            --query 'ResponseCode' --output text)

          [ "$RESPONSE_CODE" -eq 0 ] || exit "$RESPONSE_CODE"
