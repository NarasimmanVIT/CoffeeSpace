name: Deploy Frontend to EC2 via SSM

on:
  push:
    branches: [ master ]        # change to main if needed
  workflow_dispatch:

env:
  AWS_REGION: ap-south-1
  IMAGE_NAME: coffeespace-frontend
  ECR_REPO: coffeespace-frontend
  EC2_INSTANCE_IDS: i-0dbc533f9c7a8cf30   # same instance as backend

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Validate AWS secrets
        run: |
          [ -n "${{ secrets.AWS_ACCESS_KEY_ID }}" ] && [ -n "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ] \
            && echo "✅ AWS secrets are available." || { echo "❌ Missing AWS secrets"; exit 1; }

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get AWS Account ID
        run: echo "AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)" >> $GITHUB_ENV

      - name: Ensure ECR repo exists
        run: |
          aws ecr describe-repositories --repository-names "$ECR_REPO" >/dev/null 2>&1 \
          || aws ecr create-repository --repository-name "$ECR_REPO" >/dev/null 2>&1 || true

      - name: Login to ECR
        run: |
          aws ecr get-login-password --region "$AWS_REGION" \
          | docker login --username AWS --password-stdin "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"

      - name: Build Docker image
        run: |
          docker build \
            --build-arg VITE_API_BASE_URL=${{ secrets.VITE_API_BASE_URL }} \
            -t "${IMAGE_NAME}:latest" .

      - name: Tag Docker image
        run: |
          docker tag "${IMAGE_NAME}:latest" "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO}:latest"
          docker tag "${IMAGE_NAME}:latest" "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO}:${GITHUB_SHA}"

      - name: Push image to ECR
        run: |
          docker push "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO}:latest"
          docker push "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO}:${GITHUB_SHA}"

      - name: Deploy to EC2 via SSM
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
          VITE_API_BASE_URL: ${{ secrets.VITE_API_BASE_URL }}
        run: |
          read -r -d '' REMOTE_SCRIPT <<'EOSH'
          set -e

          FRONTEND_DIR=/home/ubuntu/frontend
          AWS_REGION="%AWS_REGION%"
          AWS_ACCOUNT_ID="%AWS_ACCOUNT_ID%"
          VITE_API_BASE_URL="%VITE_API_BASE_URL%"

          mkdir -p "$FRONTEND_DIR"

          # Docker & Compose installation
          if ! command -v docker >/dev/null 2>&1; then
            sudo apt-get update -y && sudo apt-get install -y docker.io
          fi
          if ! docker compose version >/dev/null 2>&1; then
            sudo apt-get install -y docker-compose-plugin || sudo apt-get install -y docker-compose
          fi

          docker network inspect app_net >/dev/null 2>&1 || docker network create app_net

          # Create .env for Docker Compose
          cat > "$FRONTEND_DIR/.env" <<ENVEOF
          AWS_ACCOUNT_ID=$AWS_ACCOUNT_ID
          AWS_REGION=$AWS_REGION
          VITE_API_BASE_URL=$VITE_API_BASE_URL
          ENVEOF

          # Write docker-compose.yml
          cat > "$FRONTEND_DIR/docker-compose.yml" <<'YAMLEOF'
          version: "3.9"

          networks:
            app_net:
              external: true

          services:
            frontend:
              image: "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/coffeespace-frontend:latest"
              container_name: coffeespace-frontend
              restart: always
              ports:
                - "80:80"
              networks:
                - app_net
              volumes:
                - ./nginx.conf:/etc/nginx/conf.d/default.conf:ro
          YAMLEOF

          # Nginx config
          cat > "$FRONTEND_DIR/nginx.conf" <<'NGINXEOF'
          server {
            listen 80;
            server_name _;

            root /usr/share/nginx/html;
            index index.html index.htm;

            location / {
              try_files $uri /index.html;
            }

            location /api/ {
              proxy_pass ${VITE_API_BASE_URL};
              proxy_http_version 1.1;
              proxy_set_header Host $host;
              proxy_set_header X-Real-IP $remote_addr;
              proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto $scheme;
            }
          }
          NGINXEOF

          aws ecr get-login-password --region "$AWS_REGION" \
            | docker login --username AWS --password-stdin "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"

          docker network connect app_net coffeespace-backend || true

          cd "$FRONTEND_DIR"
          docker compose pull
          docker compose up -d --remove-orphans
          docker image prune -f || true
          EOSH

          REMOTE_SCRIPT="${REMOTE_SCRIPT//%AWS_REGION%/${AWS_REGION}}"
          REMOTE_SCRIPT="${REMOTE_SCRIPT//%AWS_ACCOUNT_ID%/${AWS_ACCOUNT_ID}}"
          REMOTE_SCRIPT="${REMOTE_SCRIPT//%VITE_API_BASE_URL%/${VITE_API_BASE_URL}}"

          COMMAND_ID=$(aws ssm send-command \
            --targets "Key=instanceIds,Values=${{ env.EC2_INSTANCE_IDS }}" \
            --document-name "AWS-RunShellScript" \
            --comment "Deploy frontend stack" \
            --parameters commands="$(printf '%q' "$REMOTE_SCRIPT")" \
            --query "Command.CommandId" \
            --output text)

          echo "SSM Command ID: $COMMAND_ID"

          while true; do
            STATUS=$(aws ssm get-command-invocation \
              --instance-id "${{ env.EC2_INSTANCE_IDS }}" \
              --command-id "$COMMAND_ID" \
              --query 'Status' --output text)
            echo "Current status: $STATUS"
            [[ "$STATUS" =~ ^(Success|Failed|DeliveryTimedOut|ExecutionTimedOut|Cancelled)$ ]] && break
            sleep 5
          done

          RESPONSE_CODE=$(aws ssm get-command-invocation \
            --instance-id "${{ env.EC2_INSTANCE_IDS }}" \
            --command-id "$COMMAND_ID" \
            --query 'ResponseCode' --output text)
          [ "$RESPONSE_CODE" -eq 0 ] || exit "$RESPONSE_CODE"
